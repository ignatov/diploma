\subsection{Архитектура компилятора Extensible Kotlin}\label{architecture}
Компилятор Extensible Kotlin построен на основе компилятора Kotlin.

Рассмотрим стандартные шаги компиляции:
\begin{itemize}
\item[---] Лексический анализ;
\item[---] Синтаксический анализ;
\item[---] Построение внутреннего представления программы;
\item[---] Разрешение имен и анализ типов;
\item[---] Генерация байт-кода;
\end{itemize}

Существенным отличием компилятора Extensible Kotlin от компилятора Kotlin являются две дополнительные фазы компиляции~--- модификация внутреннего представления программы и последующие статические проверки.
Последний, перед генерацией байт-кода, шаг повторного разрешение имен и анализа типов необходим для получения гарантий того, что трансформация выполнена корректно.
\begin{code}
То есть шаги компиляции программы с помощью компилятора Extensible Kotlin выглядят следующим образом:
\begin{itemize}
\item[---] Лексический анализ;
\item[---] Синтаксический анализ;
\item[---] Построение внутреннего представления программы;
\item[---] Разрешение имен и анализ типов;
\item[---] \textbf{Трансформация внутреннего представления программы;}
\item[---] \textbf{Разрешение имен и анализ типов вновь полученных структур;}
\item[---] Генерация байт-кода;
\end{itemize}
\end{code}

Полужирным начертанием выделены новые, дополнительные фазы компиляции, которые необходимы для работы механизма загрузки типов.

Благодаря удобной архитектуре с раздельными фазами, получилось эффективно расширить компилятор языка, привнеся новую функциональность,
а также повторно использовать фазу разрешения имен и анализа типов для модифицированного представления программы.

Отдельно стоит отметить, что подобное внутреннее устройство компилятора позволило повысить эффективность разработки тех расширений, которые представлены в данной работе.

\subsubsection{Расширяемые компиляторы других языков программирования}
Многие современные компиляторы позволяют добавлять разработчикам добавлять новые возможности в компилятор без модификации самого компилятора с помощью специальных пользовательских расширений (compiler plugins).

Такой подход позволяет получить несколько преимуществ:
\begin{itemize}
\item[---] Сокращается время разработки новых возможностей самого компилятора. Необходимо собирать и тестировать только тот код, который непосредственно отвечает за реализацию вновь созданной функциональности.
\item[---] Возможно создание и поддержка расширений компилятора, которые не могут попасть в основную ветку разработки по тем или иным причинам.
\item[---] Снижается порог вхождения, необходимый для модификации или разработки новых возможностей компилятора.
\end{itemize}

Изначально данная концепция получила развитие в экспериментальных компиляторах языков, которые являются диалектами уже существующих: MetaOCaml~\cite{metaocaml}, MetaML~\cite{metaml}, 'C~\cite{extendible-c}.
Но на текущим момент, пользовательские расширения появились в таких компиляторах как
Scala Compiler~\cite{scala-spec},
Glasgow Haskell Compiler\footnote{\url{http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/compiler-plugins.html}}, GNU Compiler Collection\footnote{\url{http://gcc.gnu.org/wiki/plugins}}.

Обычно, подобные расширения выполняют дополнительные статические проверки на этапе компиляции. Но есть и весьма неординарные~--- например, расширение\footnote{\url{http://code.google.com/p/gcc-vcg-plugin}} для графического представления внутренних структур компилятора.

В качестве примера, можно отметить тот факт, что компилятор языка Scala полностью состоит из расширений компилятора. На сегодняшний день в стандартной поставке существует 21 фаза компиляции, каждая из которой обусловлена наличием того или иного расширения. Например, код расширения\footnote{\url{http://www.scala-lang.org/node/140}}, которое проверяет деление на ноль в явном виде, должно выполняться после стадии проверки всех ссылочных значений. Исходный код этого расширения занимает всего тридцать строк кода. Что показывает мощь и выразительность данного подхода.

По схожему принципу построена работа компилятора Extensible Kotlin. Подробнее об устройстве каждого реализованного расширения компилятора рассказывается в соответствующей главе.

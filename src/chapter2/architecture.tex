\subsection{Архитектура компилятора Extensible Kotlin}\label{architecture}
Компилятор Extensible Kotlin построен на основе компилятора Kotlin.

Рассмотрим стандартные шаги компиляции:
\begin{itemize}
\item[---] Лексический анализ;
\item[---] Синтаксический анализ;
\item[---] Построение внутреннего представления программы;
\item[---] Разрешение имен и анализ типов;
\item[---] Генерация байт-кода;
\end{itemize}

Существенным отличием компилятора Extensible Kotlin от компилятора Kotlin является дополнительная фаза компиляции~--- трансформация внутреннего представления программы  и последующие статические проверки. То есть шаги компиляции программы с помощью компилятора Extensible Kotlin выглядят следующим образом:
\begin{itemize}
\item[---] Лексический анализ;
\item[---] Синтаксический анализ;
\item[---] Построение внутреннего представления программы;
\item[---] Разрешение имен и анализ типов;
\item[---] Трансформация внутреннего представления программы;
\item[---] Разрешение имен и анализ типов вновь полученных структур;
\item[---] Генерация байт-кода;
\end{itemize}

\subsubsection{Расширяемые компиляторы других языков программирования}
Многие современные компиляторы позволяют добавлять разработчикам добавлять новые возможности в компилятор без модификации самого компилятора с помощью специальных пользовательских расширений (compiler plugins).

Такой подход позволяет получить несколько преимуществ:
\begin{itemize}
\item[---] Сокращается время разработки новых возможностей самого компилятора. Необходимо собирать и тестировать только тот код, который непосредственно отвечает за реализацию вновь созданной функциональности.
\item[---] Возможно создание и поддержка расширений компилятора, которые не могут попасть в основную ветку разработки по тем или иным причинам.
\item[---] Снижается порог вхождения, необходимый для модификации или разработки новых возможностей компилятора.
\end{itemize}

В основном, такие языки являются расширениями уже существующих языков:
Изначально данная концепция получила развитие в экспериментальных компиляторах языков, которые являются диалектами уже существующих: MetaOCaml~\cite{metaocaml}, MetaMl~\cite{metaml}, 'C~\cite{extendible-c}.
Но на текущим момент, пользовательские расширения появились в таких компиляторах как
Scala Compiler~\cite{scala-spec}, Glasgow Haskell Compiler\footnote{\url{http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/compiler-plugins.html}}, GNU Compiler Collection\footnote{\url{http://gcc.gnu.org/wiki/plugins}}.

Обычно, подобные расширения выполняют дополнительные статические проверки на этапе компиляции. Но есть и весьма неординарные~--- например, расширение\footnote{\url{http://code.google.com/p/gcc-vcg-plugin}} для графического представления внутренних структур компилятора.

В качестве примера, можно отметить тот факт, что компилятор языка Scala полностью состоит из расширений компилятора. На сегодняшний день в стандартной поставке существует 21 фаза компиляции, каждая из которой обусловлена наличием того или иного расширения. Например, код расширения\footnote{\url{http://www.scala-lang.org/node/140}}, которое проверяет деление на ноль в явном виде, должно выполняться после стадии проверки всех ссылочных значений. Исходный код этого расширения занимает всего тридцать строк кода. Что показывает мощь и выразительность данного подхода.

По схожему принципу построена работа компилятора языка Extensible Kotlin.

\todo{Нужно подробнее.}
\subsection{Загрузчик типов из заголовочных файлов на языке С}\label{c-loader}
Иногда перед прикладным программистом ставится задача перенесения существующего кода на новую программную платформу.
В ходе таких работ может возникнуть необходимость в вызове кода из библиотек, доставшихся в наследство (legacy code).

Также большинство современных операционных систем предоставляют доступ в виде программного интерфейса на языке C.

Для таких случаев, компилятор Extensible Kotlin предоставляет возможность загрузки структур данных и функций из заголовочных файлов на языке C.
В ходе этого процесса (загрузки типов), не только структуры данных преобразуются в классы, но и появляется дополнительная возможность~--- превращение функций на языке C в функции на целевом языке (в данном случае на Kotlin).

\subsubsection{Постановка задачи}
\td Необходимо реализовать механизм загрузки типов и функций для программ на языке С.
Сравнить полученный механизм с существующими аналогами по нескольким характеристикам: количество кода, которое необходимо написать для реализации самого загрузчика и количество кода, которое необходимо написать для его использования.

\subsubsection{Пример входных данных}
Рассмотрим следующий пример. Представим, что у нас есть библиотека на языке C, а также её заголовочный файл со следующим содержанием:
\begin{code}
\lstinputlisting[language=C, caption={Пример заголовочного файла на языке С.}, label=point-h-example]{listings/point.h}
\end{code}

\subsubsection{Импортирование заголовочного файла на языке C программу на языке Extensible Kotlin}
Аналогично подключению загрузчика типов для схем XML, подключение заголовочного файла на языке C в программу на языке \todo{Extensible} Kotlin происходит явно.
Это действие является предварительным этапом. Сразу после подключения, декларации функций и классы, отождествленные со структурами данных, становятся доступны как для среды разработки, так и для компилятора.
\begin{code}\begin{lstlisting}[caption={Подключение заголовочного файла на языке C в программу на языке Kotlin.}, label={c-type-loading-extension-point}]
#TODO
\end{lstlisting}\end{code}

\subsubsection{Примеры использования}
После подключения загрузчика и импорта загруженных классов и функций можно приступать к вызову кода на языке C из программы на языке Kotlin:
\begin{code}\begin{lstlisting}[caption={Пример работы с функциями и структурами данных, загруженных из заголовочного файла~\ref{point-h-example}.}, label=point-example]
import org.libs.point.*

fun main(args: Array<String>) {
  val zero: Point = Point(0, 0)
  move(zero, 100, 100)
  val result = copy_with_offset(zero, 100, 100)
  print("x: " + result.x + ", y: " + result.y)
}
\end{lstlisting}\end{code}
\subsubsection{Алгоритм работы загрузчика функций и типов}

Базовой библиотекой для взаимодействия с кодом на языке C был выбран пакет \path{com.sun.jna}\footnote{\url{http://jna.java.net}}~\cite{jna-book}.
Преимуществом данного решения является прозрачная интеграция с кодом на языке C без дополнительных модификаций на вызываемой стороне.
То есть код на С, который вызывается из программы на языке Java или Kotlin, не требует дополнительных изменений.
Не для всех библиотек, обеспечивающих нативный доступ верно данное утверждение.
Например, при использовании JNI~\cite{jni-spec} это не так: код на C, который вызывается из программы на языке Java, должен быть написан специальным образом.
Рассмотрим функцию на языке C, которая возвращает переданную ей строку без модификаций:

\begin{code}\begin{lstlisting}[language=C, caption={Пример функции на языке C, которая доступна для вызова через библиотеку JNI.}, label=jni-example]
JNIEXPORT jstring JNICALL Java_nativetest_returnString
  (JNIEnv *env, jobject thisobject, jstring s) {
  return s;
}
\end{lstlisting}\end{code}

При использовании библиотеки JNA можно вызывать функцию с более простой сигнатурой:
\begin{code}\begin{lstlisting}[language=C, caption={Пример функции на языке C, аналогичной функции из примера~\ref{jni-example}, которая доступна для вызова через библиотеку JNA.}, label=jna-example]
char* return_string(char* s) {
  return s;
}
\end{lstlisting}\end{code}

Ход работы загрузчика типов из заголовочных файлов на языке C схож с ходом работы загрузчика, созданного для работы с XML.

То есть, добавляются две дополнительные фазы компиляции: первая из которых (подробнее об этой фазе написано в разделе \ref{c-tranformation-phase}) модифицирует внутреннее представление программы, а вторая заново анализирует полученную программу.

Стоит отметить, что классы для взаимодействия с кодом на языке C создаются, упаковываются в конечную сборку и вызываются во время исполнения программы.

\subsubsection{Фаза трансформации внутреннего представления программы}\label{c-tranformation-phase}
Единственной трансформацией является замена функционального литерала, которые передается как функция обратного вызова в код на C.

Рассмотрим пример заголовочного файла на языке C:

\begin{code}\begin{lstlisting}[language=C, caption={Пример заголовочного файла на языке C с декларацией функции обратного вызова.}, label=callback-c-example]
typedef void (*callback)(char *, char*);
int calculate_str_len(char *);
void register_callback(callback myc);
\end{lstlisting}\end{code}

А также реализации этих методов:
\begin{code}\begin{lstlisting}[language=C, caption={Реализация функции обратного вызова из примера~\ref{callback-c-example}.}, label=callback-c-example-impl]
#include <string.h>
#include "test.h"
static callback c;
void register_callback(callback myc) {
  c = myc;
}
int calculate_str_len(char *name) {
  (*c)("Hello from C", name);
  return strlen(name);
}
\end{lstlisting}\end{code}

При использовании языка Java и библиотеки JNA для доступа к функциям обратного вызова необходимо использовать следующий синтаксис:
\begin{code}\begin{lstlisting}[language=Java, caption={Пример передачи функции обратного вызова в языке Java с использованием библиотеки JNA.}, label=java-callback-example]
class MyCallBack implements org.jna.Callback {
  public void callback(String param1, String param2) {
    System.out.println(
      "From C received 2 params:" + param1 + "," + param2
    );
  }
}
public class App {
  public static void main(String[] args) {
    MyLib.INSTANCE.register_callback(new MyCallBack());
  }
}
\end{lstlisting}\end{code}

Ясно, что появление класса \path{MyCallBack} обусловлено только конвенциями, которые приняты в языке Java.
Потому как класс требуется только для хранения метода \path{callback} внутри себя.

Синтаксис языка Kotlin позволяет передавать функциональные литералы, а не классы в качестве параметров функций.
Данная возможности позволяет убрать промежуточные <<классы-обертки>>.
Таким образом, функциональный литерал передается в качестве функции обратного вызова в явном виде:
\begin{code}\begin{lstlisting}[caption={Пример передачи функционального литерала в качестве функции обратного вызова.}, label=kotlin-callback-example]
fun main(args : Array<String>) {
  MyLib.INSTANCE.register_callback {
    p1, p2 -> println("From C received 2 params:" + p1 + "," + p2);
  }
}
\end{lstlisting}\end{code}

В результате, снижается <<синтаксический шум>>, который присущ программам на языке Java, тем самым повышается читаемость программы.

Во время трансформации, функциональные литералы переданные в функции вида \path{register_callback} оборачиваются в объекты, реализующие интерфейс \path{Callback} для совместимости с библиотекой JNA.
Также в явном виде выводятся и добавляются типы аргументов и результирующего значения функционального литерала.

Промежуточное представление выглядит следующим образом:
\begin{code}\begin{lstlisting}[caption={Промежуточное представление программы с трансформацией функции обратного вызова.}, label=transitional-callback-representation]
fun main(args : Array<String>) {
  MyLib.INSTANCE.register_callback(
    object : org.jna.Callback {
      fun callback(p1 : String, p2 : String) : Unit {
        println("From C received 2 params:" + p1 + "," + p2);
      }
    })
}
\end{lstlisting}\end{code}

\subsubsection{Результаты}
Реализован механизм загрузки типов из заголовочных файлов на языке C в компиляторе языка Extensible Kotlin.

Проведен сравнительный анализ со сходными механизмами для работы с библиотеками на языке C из программ на языке Java.

Преимущества предложенного подхода перед механизмами, призванными решать те же самые задачи:
\begin{itemize}
\item[---] Автоматическое создание интерфейсов для работы с библиотеками на языке C по сравнению с ручным созданием таких же интерфейсов для библиотеки JNA.
\item[---] Лучшая согласованность с программой на языке C.
  При изменении программы на C невозможно забыть изменить программу на языке Kotin, которая использует загрузчик типов из C.
  Тем самым изводится один из типов ошибок, присущий разработке на смешанных языках или платформах, а именно~--- несогласованность версий.
\item[---] Дополнительный, но не столь очевидный плюс предложенного подхода~--- упрощение рабочего процесса программиста.
  Требуется выполнять запуск только одного компилятора, а не нескольких инструментов (генератора кода, а затем компилятора).
\item[---] Отдельно стоит отметить тот факт, что при предлагаемом подходе не требуется хранить сгенерированный (или написанный вручную) код для работы с библиотекой на языке С в системе контроля версий.
  Тем самым выполняется одно из правил <<хорошего тона>> разработчиков программного обеспечения~--- <<отсутствие сгенерированных артефактов в системе контроля версий>>~\cite{art-of-agile}.
\end{itemize}
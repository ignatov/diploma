\subsection{Загрузчик типов из заголовочных файлов на языке С}
Иногда перед прикладным программистом ставится задача перенесения существующего кода на новую программную платформу.
В ходе таких работ может возникнуть необходимость в вызове кода из библиотек, доставшихся в наследство (legacy code).

Для таких случаев язык Extensible Kotlin предоставляет возможность загрузки структур данных и функций из заголовочных файлов на языке C.
При загрузке, структуры данных преобразуются в классы, а функции~--- в функции.

\subsubsection{Постановка задачи}
\td Необходимо реализовать механизм загрузки типов и функций для программ на языке С. Сравнить полученный механизм с существующими аналогами по нескольким характеристикам: количество кода, которое необходимо написать для реализации самого загрузчика и количество кода, которое необходимо написать для его использования.

\subsubsection{Пример входных данных}
Рассмотрим следующий пример. Представим, что у нас есть библиотека на языке C, а также её заголовочный файл со следующим содержанием:
\lstinputlisting[language=C]{listings/point.h}

\subsubsection{Импортирование заголовочного файла на языке C программу на языке Extensible Kotlin}
Аналогично подключению загрузчика типов для схем XML, подключение происходит явно. \td

\subsubsection{Примеры использования}
После подключения загрузчика и импорта загруженных классов и функций можно приступать к вызову кода на языке C из программы на языке Kotlin:
\begin{lstlisting}
import org.libs.point.Point, move, copy_with_offset

fun main(args: Array<String>) {
  val zero: Point = Point(0, 0)
  move(zero, 100, 100)
  val result = copy_with_offset(zero, 100, 100)
  print("x: " + result.x + ", y: " + result.y)
}
\end{lstlisting}
\subsubsection{Алгоритм работы загрузчика функций и типов}

Ход работы загрузчика типов из заголовочных файлов на языке C схож с ходом работы загрузчика, созданного для работы с XML.

То есть, добавляются две дополнительные фазы компиляции: первая из которых (подробнее об этой фазе написано в разделе \ref{c-tranformation-phase}) модифицирует внутреннее представление программы, а вторая заново анализирует полученную программу.

Стоит отметить, что классы для взаимодействия с кодом на языке C создаются, упаковываются в конечную сборку и вызываются во время исполнения программы.

\subsubsection{Фаза трансформации внутреннего представления программы}\label{c-tranformation-phase}
Единственной трансформацией является замена функционального литерала, которые передается как функция обратного вызова в код на C.

Рассмотрим пример заголовочного файла на языке C:

\begin{lstlisting}[language=C]
typedef void (*callback)(char *, char*);
int calculate_str_len(char *);
void register_callback(callback myc);
\end{lstlisting}

А также реализации этих методов:
\begin{lstlisting}[language=C]
#include <string.h> // TODO: remove imports
#include "test.h"
static callback c;
void register_callback(callback myc) {
  c = myc;
}
int calculate_str_len(char *name) {
  (*c)("Hello from C", name); // call Kotlin method
  return strlen(name);
}
\end{lstlisting}

Для доступа из языка Java к функциям обратного вызова необходимо использовать следующий синтаксис:
\begin{lstlisting}[language=Java]
class MyCallBack implements org.jna.Callback {
  public void callback(String param1, String param2) {
    System.out.println("From C received 2 params: " + param1 + ", " + param2);
  }
}
public class App {
  static MyLib lib = MyLib.INSTANCE;
  public static void main(String[] args) {
    lib.register_callback(new MyCallBack());
  }
}
\end{lstlisting}

Ясно, что появление класса \texttt{MyCallBack} обусловлено только конвенциями, которые приняты в языке Java. Потому как класс нужен только для хранения метода \texttt{void callback} внутри себя.

При использовании функций обратного вызова из языка Extensible Kotlin можно передавать их явно:
\begin{lstlisting}
fun main(args : Array<String>) {
  MyLib.INSTANCE.register_callback({
      (p1 : String, p2 : String) -> 
          println("From C received 2 params: " + param1 + ", " + param2);
    })
}
\end{lstlisting}

Во время трансформации, функциональные литералы переданные в функции вида \texttt{register\_callback} оборачиваются в объекты, реализующие интерфейс \texttt{Callback} для совместимостью с библиотекой JNA.

Промежуточное представление выглядит следующим образом:
\begin{lstlisting}
fun main(args : Array<String>) {
  MyLib.INSTANCE.register_callback(object : org.jna.Callback {
      fun callback(p1 : String, p2 : String) : String {
        println("From C received 2 params: " + param1 + ", " + param2);
      }
    })
}
\end{lstlisting}

\subsubsection{Результаты}
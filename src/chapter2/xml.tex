\subsection{Загрузчик типов из схем XML}\label{xml-loader}

\subsubsection{Пример входных данных}

Представим, что у нас есть следующая схема, описывающая XML файлы, которые мы хотим считывать в нашей программе:
\lstinputlisting{listings/shiporder.xsd}

После изучения схемы видно, что у элемента shiporder есть список дочерних элементов item, у каждого из которых есть три обязательных поля: строковое title, положительное целое quantity, десятичное price (описывающее стоимость товара) и одно необязательное строковое~--- note.

Подобные рассмотрения приводят к мысли, что схемы данных XML могут один к одному транслироваться в классы языка программирования и обратно.

Следовательно, имеет смысл написание специального расширения языка, которое позволит автоматически загружать типы данных из файлов со схемами и оперировать со статически типизированной информацией, которая согласована с этими схемами.

Пример файла, удовлетворяющей схеме, приведенной выше:
\lstinputlisting{listings/order.xml}

\subsubsection{Примеры языков со встроенной поддержкой XML}
Некоторые современные языки программирования обладают встроенной поддержкой XML.
\begin{description}
\item[Scala.] В языке Scala~\cite{scala-spec} литералы XML являются частью синтаксиса: \td

\begin{lstlisting}
val document =
  <root>
    <child>
      <grandchild an_attribute="value1" />
      <grandchild an_attribute="value2" />
    </child>
  </root>
\end{lstlisting}
Во внутреннем представлении компилятора каждый XML--литерал является экземпляром класса \path{scala.xml.Elem}~\footnote{http://www.scala-lang.org/api/current/scala/xml/Elem.html}:

\begin{lstlisting}
val document =
scala.xml.Elem(null, "root", scala.xml.Null, scala.xml.TopScope,
  scala.xml.Elem(null, "child", scala.xml.Null, scala.xml.TopScope,
    scala.xml.Elem(null, "grandchild",
      new scala.xml.UnprefixedAttribute(
        "an_attribute","value1", scala.xml.Null),
      scala.xml.TopScope,
      scala.xml.Text("content1")
    ),
    scala.xml.Elem(null, "grandchild",
      new scala.xml.UnprefixedAttribute(
        "an_attribute","value2", scala.xml.Null),
      scala.xml.TopScope,
      scala.xml.Text("content2")
    )
  )
) 
\end{lstlisting}

В языке Scala для работы с XML предлагается достаточно мощный интерфейс. Именно он и используется в многочисленных каркасах для создания веб-приложений (web application frameworks), написанных на Scala. \td

Также стоит отметить критику пакета \path{scala.xml} о недостаточной производительности, несогласованности некоторых методов и т.п.

Главным критиком этого пакета является Daniel Spiewak, который предлагает свою, улучшенную версию библиотеки для нативной работы с XML:
Anti-XML~\footnote{http://anti-xml.org/}.

\item[ECMAScript for XML.] Сходный синтаксис применён и в расширении языка ECMAScript~--- E4X~\cite{E4X} (ECMAScript for XML).

Следующая программа на этом диалекте ECMAScript:

\begin{lstlisting}
var sales = <sales vendor="John">
    <item type="peas" price="4" quantity="6"/>
    <item type="carrot" price="3" quantity="10"/>
    <item type="chips" price="5" quantity="3"/>
  </sales>;
console.log(sales.@vendor);
console.log(sales.item[0]);
\end{lstlisting}
выведет на экран \texttt{John} и \texttt{<item type="peas" price="4" quantity="6"/>} соответственно.

Стоит отметить, что широкой распространенности расширения языка ECMAScript for XML не получило.
Хотя в некоторых продуктах, таких как Mozilla Firefox~\footnote{https://developer.mozilla.org/en/E4X} и 
OpenOffice.org~\footnote{http://www.ecma-international.org/publications/standards/Ecma-376.htm} существует поддержка этого диалекта.

Отдельно нужно сказать, что в силу своей природы, ECMAScript не может дать никаких типовых гарантий (как статических, так и динамических) при работе с XML. \todo{перефразировать последнее предложение}

\end{description}

\subsubsection{Импортирование типов из схемы XML в программу на языке Extensible Kotlin}
Механизм загрузки типов из схем XML в языке Extensible Kotlin схож с механизмом в языке Gosu\td.
В программу необходимо подключить XSD файл, описывающий типы 
\td

\subsubsection{Пример использования}
После подключения схемы в программу, загруженные типы станут доступны для использования: \td

\begin{lstlisting}
val bread = item("Bread", null, 2, 10.0)
val order = shiporder(List<item>(bread))
println(order.toXML())

val fromFile : shiporder = loadFromFile("order.xml")
for (i in fromFile.itemList)
  println(i.title)
\end{lstlisting}

\subsubsection{Алгоритм работы загрузчика типов}

Первым делом, еще до компиляции программы, по подключенным схемам XML строятся описания (дескрипторы) классов на языке Kotlin следующего вида:

\begin{lstlisting}
class Item(
  var title : String,
  var quantity : Int,
  var price : Double
)
public class Shiporder(
  var orderperson : String,
  var shipto : Shipto,
  val items : List<Item>
)
\end{lstlisting}

После подключения XML схемы в пакет компиляции, вся информация о загруженных типах становится доступна в среде разработки. То есть доступна навигация, авто--дополнение, поиск вхождений и тому подобные функции, которые присущи современным средам разработки.

Фазы лексического и грамматического разбора, построения внутреннего представления программы и первичного статического анализа полностью унаследованы от базового компилятора языка Kotlin. Но перед генерацией байт-кода присутствуют 2 новых фазы, которых нет в стандартном компиляторе, а именно:

\begin{description}
\item[Трансформация внутреннего представления программы.] При успешном завершении проверок из предыдущего пункта начинается фаза трансформации внутреннего представления программы. Подробное описание алгоритма работы этого шага компиляции можно прочитать в разделе \ref{xml-tranformation-phase}.
\item[Статический анализ вновь полученных структур.]
Аналогично пункту, который предшествовал изменению модели, выполняются статические проверки корректности программы с целью проверки того, что трансформация была завершена корректно.
\end{description}

При успешном завершении проверок из последнего пункта генерируется итоговый байт-код.
  
\subsubsection{Фаза трансформации внутреннего представления программы}\label{xml-tranformation-phase}
Главная суть фазы трансформации~--- заменить все вхождения загруженных типов (в любых позициях: будь то типовой параметр функции, тип возвращаемого значения, тип переменной и т.п.) на один единственный, который необходим для работы с документом XML.

В данной работе таким универсальным классом стал класс \path{org.jdom.Element} из библиотеки JDOM~\footnote{http://www.jdom.org/}, который и является достаточно удобным интерфейсом для работы с документами XML.

Изменение программы затрагивает только те типы, классы, которых были сгенерированы во время загрузки. В этой секции, если не сказано обратного, подразумевается, что разговор ведется только про такие типы.

Во время модификации программы выполняются следующие преобразования:
\begin{itemize}
\item[---] Все вхождения типов загруженных классов превращаются в тип \path{Element}~--- тип класса, необходимый для операция на деревом XML документа.
\item[---] Все вызовы конструкторов загруженных классов замещаются вызовом конструктора класса \path{Element}.
\item[---] Все обращения на чтение к свойствам загруженных классов (в языке Kotlin нет полей, есть свойства класса) заменяются на обращения к необходимому узлу дерева XML.
\item[---] Аналогично трансформируются операции на запись в свойства загруженных классов.
\end{itemize}

\subsubsection{Результаты}
Реализован механизм загрузки типов из схем XML в языке Extensible Kotlin.

Проведен сравнительный анализ как со сходными механизмами извлечения типов, доступными в языках F\# и Gosu, так и со стандартными решениями, которые используются для работы со схемами данных, представленными в виде схем XML (XSD файлов).
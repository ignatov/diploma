\subsection{Загрузчик типов из схем XML}

\subsubsection{Пример входных данных}

Представим, что у нас есть следующая схема, описывающая XML файлы, которые мы хотим считывать в нашей программе:
\lstinputlisting{listings/shiporder.xsd}

После изучения схемы видно, что у элемента shiporder есть список дочерних элементов item, у каждого из которых есть три обязательных поля: строковое title, положительное целое quantity, десятичное price (описывающее стоимость товара) и одно необязательное строковое~--- note.

Подобные рассмотрения приводят к мысли, что схемы данных XML могут один к одному транслироваться в классы языка программирования и обратно.

Следовательно, имеет смысл написание специального расширения языка, которое позволит автоматически загружать типы данных из файлов со схемами и оперировать со статически типизированной информацией, которая согласована с этими схемами.

Пример файла, удовлетворяющей схеме, приведенной выше:
\lstinputlisting{listings/order.xml}

\subsubsection{Примеры языков со встроенной поддержкой XML}
Некоторые современные языки программирования обладают встроенной поддержкой XML.
В языке Scala~\cite{scala-spec} литералы XML являются частью синтаксиса: \td

\begin{lstlisting}
object XMLTest extends Application {
  val page = 
  <html>
    <head>
      <title>Hello XHTML world</title>
    </head>
    <body>
      <h1>Hello world</h1>
      <p><a href="scala-lang.org">Scala</a> talks XHTML</p>
    </body>
  </html>;
  println(page.toString())
}
\end{lstlisting}

Сходный синтаксис применён и в расширении языка ECMAScript~--- E4X~\cite{E4X} (ECMAScript for XML):

\begin{lstlisting}
var sales = <sales vendor="John">
    <item type="peas" price="4" quantity="6"/>
    <item type="carrot" price="3" quantity="10"/>
    <item type="chips" price="5" quantity="3"/>
  </sales>;
alert(sales.@vendor);
\end{lstlisting}

\subsubsection{Импортирование типов из схемы XML в программу на языке Extensible Kotlin}
Механизм загрузки типов из схем XML в языке Extensible Kotlin схож с механизмом в языке Gosu\td.
В программу необходимо подключить XSD файл, описывающий типы 
\td

\subsubsection{Пример использования}
После подключения схемы в программу, загруженные типы станут доступны для использования: \td

\begin{lstlisting}
val bread = item("Bread", null, 2, 10.0)
val order = shiporder(List<item>(bread))
println(order.toXML())

val fromFile : shiporder = loadFromFile("order.xml")
for (i in fromFile.itemList)
  println(i.title)
\end{lstlisting}

\subsubsection{Алгоритм работы загрузчика типов}

\td Первым делом, еще до компиляции программы, по подключенным схемам XML строятся классы на языке Kotlin:

\begin{lstlisting}
#TODO: example needed
\end{lstlisting}

Фазы лексического и грамматического разбора, построения внутреннего представления программы и первичного статического анализа полностью унаследованы от базового компилятора языка Kotlin. Но перед генерацией байт-кода присутствуют 2 новых фазы, которых нет в стандартном компиляторе, а именно:

\begin{description}
\item[Трансформация внутреннего представления программы.] При успешном завершении проверок из предыдущего пункта начинается фаза трансформации внутреннего представления программы. Подробное описание алгоритма работы этого шага компиляции можно прочитать в разделе \ref{tranformation-phase}.
\item[Статический анализ вновь полученных структур.]
Аналогично пункту, который предшествовал изменению модели, выполняются статические проверки корректности программы с целью проверки того, что трансформация была завершена корректно.
\end{description}

При успешном завершении проверок из последнего пункта генерируется итоговый байт-код.
  
\subsubsection{Фаза трансформации внутреннего представления программы}\label{tranformation-phase}
Изменение программы затрагивает только те типы, классы, которых были сгенерированы во время загрузки. В этой секции, если не сказано обратного, подразумевается, что разговор ведется только про такие типы.

Во время модификации программы выполняются следующие преобразования:
\begin{itemize}
\item[---] Все вхождения типов загруженных классов превращаются в тип \texttt{Element}~--- тип класса, необходимый для операция на деревом XML документа.
\item[---] Все вызовы конструкторов загруженных классов замещаются вызовом конструктора класса \texttt{Element}.
\item[---] Все обращения на чтение к свойствам загруженных классов (в языке Kotlin нет полей, есть свойства класса) заменяются на обращения к необходимому узлу дерева XML.
\item[---] Аналогично трансформируются операции на запись в свойства загруженных классов.
\end{itemize}

\subsubsection{Результаты}
Реализован механизм загрузки типов из схем XML в языке Extensible Kotlin.

Проведен сравнительный анализ как со сходными механизмами извлечения типов, доступными в языках F\# и Gosu, так и со стандартными решениями, которые используются для работы со схемами данных, представленными в виде схем XML (XSD файлов).
\subsection{Язык Kotlin}\label{kotlin-desc}
Язык Kotlin~\cite{breslav2011}~--- объектно-ориентированный язык, совместимый с Java и предназначенный для промышленной разработки приложений и компилируемый в переносимый байт-код для виртуальной машины Java. Создание такого языка~--- это ответ на потребность в новом языке, которой был бы с одной стороны полностью совместим с языком Java, а с другой стороны решал бы многочисленные проблемы, которые существуют в языке Java, но не могут быть исправлены по ряду технических причин.

При создании языка учитывались некоторые важные требования: % TODO: перечитать и удалить лишнее.
\begin{description}
	\item[Совместимость с Java.] Платформа Java~--- это прежде всего экосистема: существует множество продуктов и библиотек, на базе которых строится огромное количество приложений.
	Поэтому для нового языка очень важна совместимость с уже существующим кодом. Важным моментом является тот факт, что миграция на новый язык может происходить постепенно, таким образом, не только код на Kotlin должен легко вызывать код на Java, но и наоборот.

	\item[Инструментальная поддержка.] Важным условием успешности языка программирования является наличие хорошей инструментальной поддержки. Центральное место среди таких инструментов занимают интегрированные среды разработки (Integrated Development Environment, IDE).
	При разработке Kotlin, IDE создается одновременно с компилятором. Такой подход позволяет одновременно решить сразу несколько проблем: модифицировать или удалить из языка концепции, которые сложны в поддержке со стороны среды разработки, а также предоставить хорошую инфраструктуру для прикладных программистов с первых дней выпуска продукта.

	\item[Статические гарантии корректности.] Во время компиляции кода на статически типизированном языке происходит множество проверок, призванных гарантировать, что те или иные ошибки не произойдут во время выполнения. Например, компилятор Java гарантирует наличие соответствующего метода у класса объекта, на котором вызывается тот или иной метод. К сожалению, кроме этого очень важного свойства, Java почти ничего не гарантирует. Это означает, что успешно скомпилированные программы завершаются с ошибками времени выполнения. Ярким примером такой исключительной ситуации является разыменование нулевой ссылки. Важным требованием к новому языку является усиление статических гарантий. Это позволит обнаруживать больше ошибок на этапе компиляции и, таким образом, сокращать затраты на тестирование.

	\item[Скорость компиляции.] Статические проверки упрощают программирование, но замедляют компиляцию, и здесь необходимо добиться определенного баланса. Опыт создания языков с мощной системой типов (яркими примерами таких языков являются Scala~\cite{scala-spec}, Haskell~\cite{haskell98}) показывает, что такой баланс найти непросто: компиляция зачастую становится неприемлемо долгой.
	Вообще, такая характеристика языка, как время компиляции проекта, может показаться второстепенной, однако в условиях когда объемы компилируемого кода очень велики, оказывается, что этот фактор весьма важен~--- ведь пока код компилируется, программист зачастую не может продолжать работу. Известным примером медленной компиляции является язык C++.

	\item[Лаконичность.] Известно~\cite{codecomplete}, что программисты зачастую тратят больше времени на чтение кода, чем на его написание, поэтому важно, чтобы конструкции, доступные в языке программирования, позволяли писать программы кратко и понятно.
	Java считается многословным языком (ceremony language~--- <<церемонный язык>>), и задача Kotlin~--- улучшить ситуацию в этом смысле.

	\item[Доступность для изучения.] Сложные статические проверки, гибкий синтаксис и конструкции высших порядков усложняют язык и затрудняют его изучение, поэтому необходимо в известной степени ограничивать набор поддерживаемых возможностей, чтобы язык был доступен для изучения. При разработке Kotlin учитывался опыт создания других современных языков, и слишком сложные концепции в язык не включались.
\end{description}

\subsubsection{Синтаксические конструкции языка Kotlin, которые необходимы для работы загрузчиков типов}

В этом разделе будут перечислены конструкции языка, синтаксические и семантические соглашения, необходимые для понимания работы механизма загрузки типов в языке Extensible Kotlin. \todo{нужно перефразировать}

\begin{description}
\item[Объявления переменных] в языке Kotlin, как и в языке Scala, происходит с помощью ключевых слов \path{val} (для неизменяемых переменных)
и \path{var} (изменяемых). Тип переменной выводится компилятором, но может быть написан и явно:
\begin{code}\begin{lstlisting}
val i = 10
var list = Array<String>(0)
val isOk : Boolean = true
\end{lstlisting}\end{code}
	\item[Классы и первичные конструкторы.] Основными сущностями, с которыми оперирует программист на языке Kotlin, как в других объектно-ориентированных языках являются классы. При объявлении класса список параметров конструктора указывается непосредственно в заголовке:
\begin{code}\begin{lstlisting}
class Point(x : Int, y : Int)
\end{lstlisting}\end{code}
	Создание экземпляра класса происходит с помощью вызова конструктора:
\begin{code}\begin{lstlisting}
val p = Point(10, 20)
\end{lstlisting}\end{code}
	\item[Функции] в языке Kotlin могут существовать не только в внутри классов, но и во вне. При этом они являются такими же полноправными сущностями (first class citizens), как и классы. То есть могут быть переданы как параметр, возвращены из функции, присвоены переменной.
\begin{code}\begin{lstlisting}
fun isEven(i : Int) : Boolean {
    if (i mod 2 == 0)
      return true
    return false
}
fun main(args : Array<String>) {
  val criteria = {(i : Int) -> isEven(i)}
  for (i in 0..10)
    System.out?.println(criteria(i))
}
\end{lstlisting}\end{code}
	\item[Свойства классов.] Параметры конструктора, отмеченные модификатором \path{val}, являются свойствами класса с тем же именем:
\begin{code}\begin{lstlisting}
class Point(val x : Int, val y : Int)

fun main(args : Array<String>) {
  val p = Point(10, 20)
  System.out?.println("x: ${p.x} y: ${p.y}")
}
\end{lstlisting}
	Программа выведет на экран строку: "\texttt{x : 10 y: 20}".
\end{code}
	% \item[Передача функциональных литералов в качестве параметров.]
	% \item[Внешние функции.]
	\item[Работа с нулевыми ссылками.] Типы в Kotlin делятся на содержащие \path{null} и не содержащие \path{null}. Типы, содержащие \path{null}, аннотируются знаком вопроса:
\begin{code}\begin{lstlisting}
fun isPalindrome(s: String?): Boolean {...}
\end{lstlisting}\end{code}

Часто встречаются длинные цепочки вызовов, каждый из которых может вернуть нулевое ссылочное значение~--- \path{null}. В результате мы получаем несколько вложенных условий, проверяющих, что вернул каждый из вызовов в цепочке. Чтобы избежать загромождения кода, в Kotlin поддерживается оператор безопасного вызова, обозначающийся <<\path{?.}>>:
\begin{code}\begin{lstlisting}
a?.getB()?.getC()?.getD()
\end{lstlisting}\end{code}
Если \path{a} не равно \path{null}, выражение \path{a?.getB()} возвращает \path{a.getB()}, иначе~--- \path{null}.

\end{description}
\section{Сравнение с существующими аналогами}

% Преимущества предложенного подхода перед механизмами, призванными решать те же самые задачи:
% \begin{itemize}
% \item[---] Автоматическое создание интерфейсов для работы с библиотеками на языке C по сравнению с ручным созданием таких же интерфейсов для библиотеки JNA.
% \item[---] Лучшая согласованность с программой на языке C.
%   При изменении программы на C невозможно забыть изменить программу на языке Kotin, которая использует загрузчик типов из C.
%   Тем самым изводится один из типов ошибок, присущий разработке на смешанных языках или платформах, а именно~--- несогласованность версий.
% \item[---] Упрощение рабочего процесса программиста. Требуется выполнять запуск только одного инструмента~--- компилятора, а не нескольких (генератора кода, а затем компилятора).
% \item[---] Отсутствие необходимости хранения сгенерированного (или написанного вручную) кода для работы с библиотекой на языке С в системе контроля версий. Тем самым выполняется одно из правил <<хорошего тона>> разработчиков программного обеспечения~--- <<отсутствие сгенерированных артефактов в системе контроля версий>>~\cite{art-of-agile}.
% \end{itemize}

\subsection{Сравнение с генераторами кода}
По сравнению со стандартными средствами промышленной разработки программного обеспечения~--- генераторами кода,
получилось достичь значительных улучшений:
\begin{itemize}
	\item[---] Лучшая согласованность с внешними интерфейсами. При изменении описания интерфейса невозможно забыть изменить программу на языке Kotlin, которая использует загрузчик типов. Тем самым изводится один из типов ошибок~--- несогласованность версий протокола и его описания.
	\item[---] Упрощение рабочего процесса программиста. Требуется выполнять запуск только одного инструмента~--- компилятора, а не нескольких (генератора кода, а затем компилятора).
	\item[---] Отсутствие необходимости хранения сгенерированного кода в системе контроля версий. Тем самым выполняется одно из правил <<хорошего тона>> разработчиков программного обеспечения~--- <<отсутствие сгенерированных артефактов в системе контроля версий>>~\cite{art-of-agile}.
\end{itemize}

Все вышеперечисленные пункты присущи загрузчикам типов как из схем XML, так и из заголовочных файлов на языке C.

\subsection{Загрузчик типов языка Gosu для работы со схемами XML}
При реализации загрузчика для XML схем удалось достигнуть такой же выразительности, как и в языке Gosu.
Но в отличии от него, удалось оставить такой важный плюс компилятора Kotlin~--- компиляцию в байт-код.
Программа на языке Gosu не может иметь бинарного представления из-за своей открытой системы типов,
которая правда и позволяет создавать загрузчики типов.

Интересно сравнить количество строк кода, необходимое для написания одной и той же программы для работы с XML файлом известной структуры на языке Java, Gosu и Kotlin.

\begin{table}\begin{center}
\begin{center}
    \begin{tabular}{ | l | c | c | p{5cm} |}
    \hline
    Язык & Количество строк & LOC/Java LOC & Замечания \\ \hline
    Java & 32 & 1 & A. \\ \hline
    Gosu & 11 & 0,3 & B. \\ \hline
    Kotlin & 12 & 0,3 & C. \\
    \hline
    \end{tabular}
\end{center}
\caption{Сравнение Java, Gosu, Kotlin}
\label{tab:comparation_java_gosu_kotlin}
\end{center}
\end{table}

\subsection{C:\@ JNI, JNA и т.д.}
\subsection{Сравнение количества кода}
\subsection{Размер бинарной сборки}
Благодаря тому, что на этапе трансформации внутреннего представления программы, все вхождения типов, загруженных их XML схемы заменяются на один единственный, который и обеспечивает работу с объектной моделью документа, получается достичь уменьшения бинарного представления программы.

В качестве эксперимента была взята программа, манипулирующая данными, полученными из XML файла, и скомпилирована с включенной и отключенной фазой трансформации внутреннего представления.

Даже на таком небольшом примере, удалось получить 70\% выигрыш в размере бинарной сборки.
\section{Сравнение с существующими аналогами}

\subsection{Генераторы кода}\label{res:generators}
По сравнению со стандартными средствами промышленной разработки программного обеспечения~--- генераторами кода,
получилось достичь значительных улучшений:
\begin{itemize}
	\item[---] Лучшая согласованность с внешними интерфейсами. При изменении описания интерфейса невозможно забыть изменить программу на языке Kotlin, которая использует загрузчик типов. Тем самым изводится один из типов ошибок~--- несогласованность версий протокола и его описания.
	\item[---] Упрощение рабочего процесса программиста. Требуется выполнять запуск только одного инструмента~--- компилятора, а не нескольких (генератора кода, а затем компилятора).
	\item[---] Отсутствие необходимости хранения сгенерированного кода в системе контроля версий. Тем самым выполняется одно из правил <<хорошего тона>> разработчиков программного обеспечения~--- <<отсутствие сгенерированных артефактов в системе контроля версий>>~\cite{art-of-agile}.
\end{itemize}

Все вышеперечисленные пункты присущи загрузчикам типов как из схем XML, так и из заголовочных файлов на языке C.

Важно подчеркнуть, что все вышеперечисленные пункты являются качественными улучшениями. В добавок к ним, также получилось достичь прогресса в некоторых количественных характеристиках.

Например, при использовании загрузчика из схем XML, удается показывать схожие результаты с достаточно лаконичным языком Gosu по такой метрике, как объем исходного кода приложения.
И в несколько раз улучшить эту характеристику в сравнении с языком Java.

Также, довольно неожиданным достижением стало уменьшение размера бинарной сборки приложения при использовании больших по объему декларативных описаний моделей за счет элиминации синтезированных типов на этапе трансформации модели.

\subsection{Язык Gosu}\label{xml-gosu-result}
При реализации загрузчика для XML схем удалось достичь такой же выразительности, как и в языке Gosu.
Но в отличии от него, удалось оставить важный плюс компилятора Kotlin~--- компиляцию в байт-код.
Программа на языке Gosu не может иметь бинарного представления из-за своей открытой системы типов,
которая правда и позволяет создавать загрузчики типов.

Интересно сравнить количество строк кода, необходимое для написания одной и той же тестовой программы для работы с XML файлом известной структуры на языке Java, Gosu и Kotlin. В таблице \ref{tab:comparation_java_gosu_kotlin} показаны абсолютные значения объема кода тестового примера, а также относительные~--- по отношению к размеру программы на языке Java.
При этом, в программе на Java будут отсутствовать статические проверки при манипуляциях с объектной моделью XML документа.


\begin{table}[!h]\begin{center}
\begin{center}
    \begin{tabular}{ | l | c | c | }
    \hline
    Язык 	& Количество строк & Количество кода относительно Java \\ \hline
    Java 	& 32 	& 1 \\ \hline
    Gosu   	& 11 	& 0,34  \\ \hline
    Kotlin 	& 12 	& 0,38 \\
    \hline
    \end{tabular}
\end{center}
\caption{Объем кода тестового примера на языках Java, Gosu и Kotlin.}
\label{tab:comparation_java_gosu_kotlin}
\end{center}
\end{table}

К сожалению, строгие методы оценки лаконичности языков и библиотек на их основе развиты слабо, но даже такой небольшой пример показывает превосходство выбранного подхода для решения выбранного круга задач.

\subsection{Размер бинарной сборки}
Благодаря тому, что на этапе трансформации внутреннего представления программы, все вхождения типов, загруженных их XML схемы заменяются на один единственный, который и обеспечивает работу с объектной моделью документа, получается достичь уменьшения бинарного представления программы.

В качестве эксперимента была взята программа, манипулирующая данными, полученными из XML файла, и скомпилирована с включенной и отключенной фазой трансформации внутреннего представления.

Даже на таком небольшом примере, который приведен в разделе \ref{xml-gosu-result}, удалось получить почти трехкратное уменьшение размера бинарной сборки. Изначальный размер программы составлял 12 килобайт; после фазы трансформации удалось высвободить 8 килобайт; финальный размер сборки составил 4 килобайта.

В другом тестовом примере, который использовал больший файл, описывающий схему XML удалось достигнуть лучших результатов. Для программы размером в 15 килобайт было синтезировано, а потом высвобождено почти 2 мегабайта дескрипторов классов.

Все же стоит отметить, что подобные результаты достигаются при небольших размерах самих приложений.
С ростом объема исходного кода, выигрыш будет не столь значительным.

\subsection{Библиотеки для взаимодействия с кодом на языке C}
Результаты, описанные в разделе \ref{res:generators}. также применим и для загрузчика типов из заголовочных файлов на языке C.

По сравнению с библиотекой JNI, получилось достичь прозрачной интеграции с уже существующим кодом на языке C.
В то время, как для вызова библиотечного кода с использованием JNI необходимо писать <<функции-обертки>>, которые бы удовлетворяли конвенциям библиотеки JNI, при использовании загрузчика типов в компиляторе Extensible Kotlin, подобных манипуляций совершать не требуется.

По сравнению же с библиотекой JNA получилось достичь согласованности интерфейса на языке C и его представления в языке Kotlin. Отдельно стоит отметить, возможность передачи функционального литерала в качестве функции обратного вызова.
Такая возможность позволяет опускать необязательные типовые параметры и писать более простой код, не создавая дополнительных абстракций (в данном случае, класс-контейнер для функции обратного вызова).

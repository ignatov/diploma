\section{Сравнение с существующими аналогами}

% Преимущества предложенного подхода перед механизмами, призванными решать те же самые задачи:
% \begin{itemize}
% \item[---] Автоматическое создание интерфейсов для работы с библиотеками на языке C по сравнению с ручным созданием таких же интерфейсов для библиотеки JNA.
% \item[---] Лучшая согласованность с программой на языке C.
%   При изменении программы на C невозможно забыть изменить программу на языке Kotin, которая использует загрузчик типов из C.
%   Тем самым изводится один из типов ошибок, присущий разработке на смешанных языках или платформах, а именно~--- несогласованность версий.
% \item[---] Упрощение рабочего процесса программиста. Требуется выполнять запуск только одного инструмента~--- компилятора, а не нескольких (генератора кода, а затем компилятора).
% \item[---] Отсутствие необходимости хранения сгенерированного (или написанного вручную) кода для работы с библиотекой на языке С в системе контроля версий. Тем самым выполняется одно из правил <<хорошего тона>> разработчиков программного обеспечения~--- <<отсутствие сгенерированных артефактов в системе контроля версий>>~\cite{art-of-agile}.
% \end{itemize}

\subsection{Генераторы кода}\label{res:generators}
По сравнению со стандартными средствами промышленной разработки программного обеспечения~--- генераторами кода,
получилось достичь значительных улучшений:
\begin{itemize}
	\item[---] Лучшая согласованность с внешними интерфейсами. При изменении описания интерфейса невозможно забыть изменить программу на языке Kotlin, которая использует загрузчик типов. Тем самым изводится один из типов ошибок~--- несогласованность версий протокола и его описания.
	\item[---] Упрощение рабочего процесса программиста. Требуется выполнять запуск только одного инструмента~--- компилятора, а не нескольких (генератора кода, а затем компилятора).
	\item[---] Отсутствие необходимости хранения сгенерированного кода в системе контроля версий. Тем самым выполняется одно из правил <<хорошего тона>> разработчиков программного обеспечения~--- <<отсутствие сгенерированных артефактов в системе контроля версий>>~\cite{art-of-agile}.
\end{itemize}

Все вышеперечисленные пункты присущи загрузчикам типов как из схем XML, так и из заголовочных файлов на языке C.

\subsection{Загрузчик типов языка Gosu для работы со схемами XML}\label{xml-gosu-result}
При реализации загрузчика для XML схем удалось достигнуть такой же выразительности, как и в языке Gosu.
Но в отличии от него, удалось оставить такой важный плюс компилятора Kotlin~--- компиляцию в байт-код.
Программа на языке Gosu не может иметь бинарного представления из-за своей открытой системы типов,
которая правда и позволяет создавать загрузчики типов.

Интересно сравнить количество строк кода, необходимое для написания одной и той же тестовой программы для работы с XML файлом известной структуры на языке Java, Gosu и Kotlin.
При этом, в программе на Java будут отсутствовать статические проверки при манипуляциях с объектной моделью XML документа.

\begin{table}[!h]\begin{center}
\begin{center}
    \begin{tabular}{ | l | c | c | }
    \hline
    Язык 	& Количество строк & LOC/Java LOC \\ \hline
    Java 	& 32 	& 1 \\ \hline
    Gosu   	& 11 	& 0,34  \\ \hline
    Kotlin 	& 12 	& 0,38 \\
    \hline
    \end{tabular}
\end{center}
\caption{Объем кода тестового примера на языках Java, Gosu и Kotlin.}
\label{tab:comparation_java_gosu_kotlin}
\end{center}
\end{table}

К сожалению, строгие методы оценки лаконичности языков и библиотек на их основе развиты слабо, но даже такой небольшой пример показывает превосходство выбранного подхода для решения выбранного круга задач.

\subsection{Размер бинарной сборки}
Благодаря тому, что на этапе трансформации внутреннего представления программы, все вхождения типов, загруженных их XML схемы заменяются на один единственный, который и обеспечивает работу с объектной моделью документа, получается достичь уменьшения бинарного представления программы.

В качестве эксперимента была взята программа, манипулирующая данными, полученными из XML файла, и скомпилирована с включенной и отключенной фазой трансформации внутреннего представления.

Даже на таком небольшом примере, который приведен в разделе \ref{xml-gosu-result}, удалось получить почти трехкратное уменьшение размера бинарной сборки. Изначальный размер программы составлял 12 килобайт; после фазы трансформации удалось высвободить 8 килобайт; финальный размер сборки составил 4 килобайта.

В другом тестовом примере, который использовал большый файл, описывающий схему XML удалось достигнуть лучших результатов. Для программы размером в 15 килобайт было синтезировано, а потом высвобождено почти 2 мегабайта дескрипторов классов.

Все же стоит отметить, что подобные результаты достигаются при небольших размерах самих приложений.
С ростом объема исходного кода, выигрыш будет не столь значительным.

\subsection{Библиотеки для взаимодействия с кодом на языке C}
Результаты, описанные в разделе \ref{res:generators}. также применим и для загрузчика типов из заголовочных файлов на языке C.

По сравнению с библиотекой JNI, получилось достичь прозрачной интергации с уже существующим кодом на языке C.
В то время, как для вызова библиотечного кода с использованием JNI необходимо писать <<функции-обертки>>, которые бы удовлетворяли конвенциям библиотеки JNI, при использовании загрузчика типов в компиляторе Extensible Kotlin, подобных манипуляций совершать не требуется.

По сравнению же с библиотекой JNA получилось достичь согласованности интерфейса на языке C и его представления в языке Kotlin. Отдельно стоит отметить, возможность передачи функционального литерала в качестве функции обратного вызова.
Такая возможность позволяет опускать необязательныне типовые параметры и писать более простой код, не создавая дополнительных абстракций (в данном случае, класс-контейнер для функции обратного вызова).
\section{Сравнение с существующими аналогами и результаты}

\subsection{Генераторы кода}\label{res:generators}
По сравнению со стандартными средствами промышленной разработки программного обеспечения~--- генераторами кода,
получилось достичь значительных улучшений:
\begin{itemize}
	\item[---] Лучшая согласованность с внешними интерфейсами. При изменении описания интерфейса невозможно забыть изменить программу на языке Kotlin, которая использует загрузчик типов. Тем самым изводится один из типов ошибок~--- несогласованность версий протокола и его описания.
	\item[---] Упрощение рабочего процесса программиста. Требуется выполнять запуск только одного инструмента~--- компилятора, а не нескольких (генератора кода, а затем компилятора).
	\item[---] Отсутствие необходимости хранения сгенерированного кода в системе контроля версий. Тем самым выполняется одно из правил <<хорошего тона>> разработчиков программного обеспечения~--- <<отсутствие сгенерированных артефактов в системе контроля версий>>~\cite{art-of-agile}.
\end{itemize}

Важно подчеркнуть, что все вышеперечисленные пункты являются качественными улучшениями, которые присущи загрузчику типов как из схем XML, так и из заголовочных файлов на языке C.

В добавок к ним, также получилось достичь прогресса в некоторых количественных характеристиках.

Например, при использовании загрузчика из схем XML, удается показывать схожие результаты с достаточно лаконичным языком Gosu по такой метрике, как объем исходного кода приложения
(более подробные результаты приведены в разделе~\ref{xml-gosu-result}).
И в несколько раз улучшить эту характеристику в сравнении с языком Java.

Также, довольно неожиданным достижением стало уменьшение размера бинарной сборки приложения при использовании больших по объему декларативных описаний моделей за счет элиминации синтезированных типов на этапе трансформации модели.

\subsection{Язык Gosu}\label{xml-gosu-result}
При реализации загрузчика для XML схем удалось достичь такой же выразительности, как и в языке Gosu.
Но в отличии от него, удалось оставить важный плюс компилятора Kotlin~--- компиляцию в байт-код.
Программа на языке Gosu не может иметь бинарного представления из-за своей открытой системы типов,
которая правда и позволяет создавать загрузчики типов.

Интересно сравнить количество строк кода, необходимое для написания одной и той же тестовой программы для работы с XML файлом известной структуры на языке Java, Gosu и Kotlin.
В таблице \ref{tab:comparation_java_gosu_kotlin} приведены как абсолютные значения объема кода тестового примера, так и относительные~--- по отношению к размеру программы на языке Java.
Стоит отметить, что в программе на Java будут отсутствовать статические проверки при манипуляциях с объектной моделью XML документа.

\begin{table}[!h]\begin{center}
\begin{center}
    \begin{tabular}{ | l | c | c | }
    \hline
    Язык 	& Количество строк & Количество кода относительно Java \\ \hline
    Java 	& 105 	& 1 \\ \hline
    Gosu   	& 36 	& 0,34  \\ \hline
    Kotlin 	& 41 	& 0,39 \\
    \hline
    \end{tabular}
\end{center}
\caption{Объем кода тестового примера на языках Java, Gosu и Kotlin.}
\label{tab:comparation_java_gosu_kotlin}
\end{center}
\end{table}

К сожалению, строгие методы оценки лаконичности языков и библиотек на их основе развиты слабо, но даже такой небольшой пример показывает превосходство выбранного подхода для решения выбранного круга задач.

\subsection{Размер бинарной сборки}
Благодаря тому, что на этапе трансформации внутреннего представления программы, все вхождения типов, загруженных их XML схемы заменяются на один единственный, который и обеспечивает работу с объектной моделью документа, получается достичь уменьшения бинарного представления программы.

В качестве эксперимента была взята программа, манипулирующая данными, полученными из XML файла, и скомпилирована с включенной и отключенной фазой трансформации внутреннего представления.

Даже на таком небольшом примере, который приведен в разделе \ref{xml-gosu-result}, удалось получить почти трехкратное уменьшение размера бинарной сборки.
Первоначальный размер программы составлял 12 килобайт; после фазы трансформации удалось высвободить 8 килобайт; финальный же размер сборки составил 4 килобайта.

В другом тестовом примере, который использовал больший файл, описывающий интерфейс взаимодействия с социальной сетью Facebook\footnote{\url{http://api.facebook.com/1.0/facebook.xsd}}, удалось достигнуть лучших результатов.
Для тестовой программы, бинарный размер которой составил 15 килобайт, было синтезировано, а после высвобождено почти 2,5 мегабайта дескрипторов классов. Такой результат обусловлен наличием 599 типов в декларативном описании интерфейса.

В последнем тестовом примере, загрузка типов производилась из схемы, описывающей интерфейс взаимодействия с утилитой для сборки программ и библиотек на языке Java~--- Maven\footnote{\url{http://maven.apache.org/maven-v4_0_0.xsd}}.
Результаты получились несколько скромнее~--- 684 килобайта дескрипторов было высвобождено при размере программы в 4,5 килобайта. Такой результат ожидаем, ведь в XML схеме, описывающей данный интерфейс насчитывается 166 классов.

Все же стоит отметить, что подобные результаты достигаются при небольших размерах самих приложений.
С ростом объема исходного кода, выигрыш будет не столь значительным. В противоположность этому, с увеличением количества типов, описываемых в протоколе взаимодействия, разница в бинарном размере приложения с удаленными дескрипторами и без оных будет возрастать.

\subsection{Библиотеки для взаимодействия с кодом на языке C}
Результаты, описанные в разделе \ref{res:generators}. также применимы и для загрузчика типов из заголовочных файлов на языке C.

По сравнению с библиотекой JNI, получилось достичь прозрачной интеграции с уже существующим кодом на языке C.
В то время, как для вызова библиотечного кода с использованием JNI необходимо писать <<функции-обертки>>, которые бы удовлетворяли конвенциям библиотеки JNI, при использовании загрузчика типов в компиляторе Extensible Kotlin, подобных манипуляций совершать не требуется.

По сравнению же с библиотекой JNA удалось достичь согласованности программного интерфейса на языке C и его представления в языке Kotlin,
благодаря автоматическому синтезу необходимых классов и функций, обеспечивающих взаимодействие по протоколу, <<загруженному>> из заголовочного файла.

Отдельно стоит отметить, возможность передачи функционального литерала в качестве функции обратного вызова.
Такая возможность позволяет опускать необязательные типовые параметры и писать более простой код, не создавая дополнительных абстракций (в данном случае, класс-контейнер для функции обратного вызова).

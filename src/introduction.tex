\clearpage
\section{Введение}

Программые интерфейсы, которые используются в прикладных приложениях, могут иметь различную природу.

Наиболее традиционным подходом являются библиотеки: они предоставляют набор классов и функций, которые и определяют программный интерфейс с точки зрения используемого языка программирования.
Важным свойством такого решения является то, что компилятор языка программирования может убедиться, что использование интерфейса происходит должным образом с помощью статической проверки типов. Использование библиотеки прекрасно подходит, если интерфейс является неизменным (или изменяется медленно).

Но есть и внешние по отношению к языку протоколы, такие как WSDL~\cite{wsdl}, XSD~\cite{xsd1, xsd2}, Protobuf~\cite{protobuf} или схемы баз данных. Для таких интерфейсов компилятор не может дать никаких статических гарантий.

Компромиссным решением является кодогенерация вспомогательных классов на используемом языке программирования, которые и используются при доступе к необходимому интерфейсу.

Но разве не здорово было бы иметь язык, который понимает внешние по отношению к нему интерфейсы и предоставляет к ним статически типизированный доступ, без создания каких-либо промежуточных <<классов-оберток>>?

Решением проблемы стали загрузчики типов (type loaders или type providers). Это специальные механизмы, которые могут использовать практически любые описания программных интерфейсов
(WSDL, XSD, Protobuf, или даже заголовочный файл на языке~C) и предоставлять в ним доступ, как будто бы это протокол взаимодействия написан на используемом языке программирования.
С помощью такого подхода предоставляется безопасный доступ к данным и полная синхронизация с внешним программным интерфейсом в случае его изменения.

Реализации таких механизмов появились в языках F\#~\cite{fsharp2010expert} и Gosu~\cite{gosuguide}. В данной работе представлен прототип загрузчика типов для компилятора Extensible Kotlin.

\clearpage
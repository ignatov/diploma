\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
% \usepackage{floatflt}
\usepackage{longtable}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{datetime}
\usepackage[cm]{fullpage}
\usepackage{indentfirst}
\usepackage{subfigure}
\usepackage[section]{placeins}
\usepackage{afterpage}
\usepackage{url}
\usepackage[unicode]{hyperref}
\usepackage{ucs}
\usepackage{listings}

\frenchspacing

% \renewcommand{\textfraction}{0.05}
% \renewcommand{\topfraction}{0.95}
% \renewcommand{\bottomfraction}{0.95}
% \renewcommand{\floatpagefraction}{0.35}
% \setcounter{totalnumber}{10}

\setlength{\parindent}     {0pt}
\setlength{\parskip}       {1.5ex plus 0.5ex minus 0.2ex}
\setlength{\marginparwidth}{80pt}

\newdateformat{rudate} {\twodigit{\THEDAY}.\twodigit{\THEMONTH}.\THEYEAR}

\title{Расширение системы типов статически типизированного языка}
\author{Игнатов Сергей}
\date{\rudate\formatdate{15}{11}{2011}}
% \date{\rudate\formatdate{15}{11}{2011}\,--\,\rudate\today}
% \date{\rudate\today}

\begin{document}

\maketitle

\section{Введение}

В современных программах зачастую возникает необходимость получать данные из различных источников.
По мере усложнения приложения могут потребоваться статические проверки при доступе к этим данным.

Другими словами, возникает необходимость представления информации из внешних источников в виде типов, свойств и методов языка программирования.
Написание этих типов руками отнимает большое количество времени, сил, также возникают сложности в поддержки сопутствующего кода.
Стандартное решение в данной ситуации~--- использование кодогенераторов, которые добавляют необходимые файлы в проект.

Загрузчики типов являются альтернативой стандартным решениям и позволяют расширять систему типов языков без написания (или генерации) дополнительного кода.
Что положительным образом влияет как на скорость разработки программного обеспечения, так и на стоимость поддержки проекта.

\section{Обзор существующих реализаций}

\subsection{Поставщики типов в языке F\#}
Одновременно с выпуском версии 3.0 языка F\# его разработчики сообщили о введении новой концепции развития~--- информационно насыщенном программировании (Information Rich Programming)~\cite{joepamer2011}.
Одним из нововведений, поддерживающим эту концепцию являются поставщики типов (Type Providers).
Поставщики типов позволяют получить статически типизированный доступ к различным источникам данных.
В стандартной поставке языка F\# существуют реализации поставщиков типов для работы с базами данных, с серверами, поддерживающими протокол OData (Open Data Protocol) и другие\footnote{Информация о поставщиках типов доступна по адресу \url{http://msdn.microsoft.com/en-us/library/hh156509(v=vs.110).aspx}.}.

\subsection{Загрузчики типов в языке Gosu}
В языке Gosu~\cite{gosuguide} существует открытая система типов (The Open Type System), которая позволяет реализовывать собственные загрузчики типов (type loaders) для любых источников.
Существенным минусом этой реализации является создание типов загружаемых данных на этапе выполнения программы, а не на этапе компиляции.
В стандартной библиотеке языка Gosu существуют загрузчики для получения типов данных из XSD, WSDL и т.д.

\section{Постановка задачи}
Разработать прототип механизма расширения системы типов языка Kotlin путем реализации механизма загрузки типов. Реализовать несколько примеров для разных источников типов.
Важное дополнение: необходимо предоставить полную поддержку для данного механизма в интегрированной среде разработки.

\section{Язык Kotlin}
В последние годы назрела потребность в новом языке, компилируемом в переносимый байт-код для виртуальной машины Java.
В результате появилось несколько проектов по созданию таких языков, один из которых~--- Kotlin\footnote{Информация о языке доступна по адресу \url{http://jetbrains.com/kotlin}.},
статически типизированный объектно-ориентированный язык, совместимый с Java и предназначенный для промышленной разработки приложений.

\section{Загрузчики типов в языке Kotlin}
В язык Kotlin планируется добавить механизм загрузки типов путем написания библиотеки предоставляющей стороннему разработчику возможность для реализации собственных загрузчиков (поставщиков) типов. Несколько загрузчиков типов будут поставляться в стандартной поставке.

В сегодняшнем описании будут приведены два примера таких поставщиков: первый предназначен для получение типов данных из схем XML (XSD), а второй~--- из заголовочных файлов библиотек, написанных на языке C.

\subsection{Загрузчик типов из схем XML}

\subsubsection{Пример входных данных}
Представим, что у нас есть следующая схема, описывающая XML файлы, которые мы хотим считывать в нашей программе:

\lstinputlisting[language=XML]{shiporder.xsd}

После изучения схемы видно, что у элемента shiporder есть список дочерних элементов item, у каждого из которых есть три обязательных поля: строковое title, положительное целое quantity, десятичное price (описывающее стоимость товара) и одно необязательное строковое~--- note.

Подобные рассмотрения приводят к мысли, что схемы данных XML могут один к одному транслироваться в классы языка программирования и обратно.

Следовательно, имеет смысл написание специального расширения языка, которое позволит автоматически загружать типы данных из файлов со схемами и оперировать со статически типизированной информацией, которая согласована с этими схемами.

Пример файла, удовлетворяющей схеме, приведенной выше:

\lstinputlisting[language=XML]{order.xml}

\subsubsection{Подключение XSD схемы в пакет компиляции программы на языке Kotlin}
Подключение схемы необходимо производить явно~--- в описании зависимостей пакета компиляции программы:
\begin{lstlisting}
package("org.example.mypackage") {
  kotlin extension XSDLoader("src/xsd/shiporder.xsd", "org.xsds.ShipOrderSchema")
}
\end{lstlisting}

\subsubsection{Пример использования}
После подключения и импорта класса схемы можно использовать всю типовую информацию полученную из файлов схемы в программе.

Как видно из приведенного ниже листинга, работа с данными из файла order.xml ничем не отличается от работы с обычными переменными и свойствами классов языка Kotlin. После обработки данных, их можно вывести на печать или сохранить в файл.

\begin{lstlisting}
import org.xsds.ShipOrderSchema

fun main(args: Array<String>) {
  val shiporder = ShipOrderSchema.loadXML("order.xml")

  for (item in shiporder.items)
    item.price = item.price * 0.95

  for (item in shiporder.items)
    println(item.price)

  ShipOrderSchema.saveToFile(order, "result.xml")
}
\end{lstlisting}

Важно отметить, что никакие дополнительные классы-обёртки для работы с данными не попадают в конечную сборку и не вызываются во время исполнения программы.
Все обращения к типам данных, которые были импортированы из схемы, заменяются на обращения к дереву XML файла.

Такой подход позволяет уменьшить конечный размер программы, а также позволяет не загромождать пространство имён.

\subsubsection{Шаги работы компилятора при использовании загрузчика типов из схем XML}
При загрузке типов из схем XML необходимо выполнить следующие шаги:
\begin{itemize}
\item[---] Импортировать схему в скрипте сборки пакета;
\item[---] Построить дескрипторы классов, свойств и функций для загруженных типов;
\item[---] Разрешить все зависимости для загруженных типов;
\item[---] Заменить структуры загруженных типов на структуры для работы с XML (для работы с XML будет использоваться библиотека JDOM);
\item[---] Разрешить зависимости заново для измененных структур;
\item[---] Сгенерировать байт-код;
\end{itemize}

\subsubsection{Текущее состояние}
На сегодняшний момент проведены следующие этапы:
\begin{itemize}
\item[---] Изучены существующие реализации для решения данной задачи (загрузки типизированных данных из XML файлов);
\item[---] Проведены тестовые испытания для одной конкретной схемы. Автоматически построены дескрипторы необходимых классов и свойств классов.
Произведена замена структур. Сгенерирован конечный байт-код.
\item[---] Продуман и создан синтаксис для типов, загружаемых из XML схем;
\item[---] Написан транслятор из XML схем в классы языка Kotlin. Этот пункт необходим для удобного и безошибочного построения необходимых дескрипторов классов.
\item[---] Написан генератор дескрипторов классов из файлов с XSD схемами;
\end{itemize}

\subsection{Загрузчик типов из схем заголовочных файлов библиотек на языке С}
\subsubsection{Обоснование}
Иногда перед прикладным программистом ставится задача перенесения существующего кода на новую программную платформу.
В ходе таких работ может возникнуть необходимость в вызове кода из библиотек, доставшихся в наследство (legacy code).

Для таких случаев язык Kotlin предоставляет возможность загрузки структур данных и функций из заголовочных файлов библиотек на языке C.
При загрузке, структуры данных преобразуются в классы, а функции~--- в функции.

\subsubsection{Пример входных данных}
Рассмотрим следующий пример. Представим, что у нас есть библиотека на языке C, а также её заголовочный файл со следующим содержанием:
\lstinputlisting[language=C]{point.h}

\subsubsection{Подключение заголовочного файла библиотеки на языке C в пакет компиляции программы на языке Kotlin}
Аналогично подключению загрузчика типов для схем XML, подключение происходит явно в скрипте сборки пакета программы:
\begin{lstlisting}
package("org.example.mypackage") {
  kotlin extension CTypeLoader("c_src/org/libs/point.h", "org.libs.point")
}
\end{lstlisting}

\subsubsection{Пример использования}
После подключения загрузчика и импорта загруженных классов и функций можно приступать к вызову кода на языке C из программы на языке Kotlin.
\begin{lstlisting}
import org.libs.point.Point, move, copy_with_offset

fun main(args: Array<String>) {
  val zero: Point = Point(0, 0)
  move(zero, 100, 100)
  val result = copy_with_offset(zero, 100, 100)
  print("x: " + result.x + ", y: " + result.y)
}
\end{lstlisting}
Стоит отметить, что в данной реализации загрузчика классы-обёртки для взаимодействия с кодом на языке C создаются, упаковываются в конечную сборку и вызываются во время исполнения программы.

\subsubsection{Шаги работы компилятора при использовании загрузчика типов из заголовочных файлов библиотек на языке С}
При загрузке типов из заголовочного файла библиотека на языке C необходимо выполнить следующие шаги:
\begin{itemize}
\item[---] Импортировать схему в скрипте сборки пакета;
\item[---] Построить дескрипторы классов, свойств и функций для загруженных типов;
\item[---] Разрешить все зависимости для загруженных типов;
\item[---] Сгенерировать байт-код для доступа к библиотеке на C (для работы с вызовами функций на C из кода на языке Kotlin используется библиотека JNA);
\item[---] Сгенерировать байт-код итоговой программы;
\end{itemize}

\subsubsection{Текущее состояние}
На сегодняшний момент проведены следующие этапы:
\begin{itemize}
\item[---] Изучены существующие реализации для решения данной задачи. Обследованы библиотеки для вызова функций, написанных на языке C и Objective C из кода на языке Java.
\item[---] Реализована автоматическая генерация байт-кода для вызова функций из библиотеки на C.
\item[---] Проведены тестовые испытания для одной конкретного примера. Вручную построены дескрипторы необходимых классов и свойств классов. Сгенерирован конечный байт-код.
\end{itemize}

\section{Связанные работы}
Сходными механизмами для расширения системы типов можно считать подключаемую систему типов (pluggable type system)~\cite{bracha}, а также различные легковесные механизмы, когда новая система типов может быть построена поверх существующей.

Подобные механизмы могут быть реализованы как в виде пакетов на базе существующих языков~--- JavaCOP~\cite{javacop2010}, Checker Framework~\cite{checkerframework2008},
так и в виде новых языков программирования~--- Strongtalk~\cite{strongtalk1993}, Newspeak~\cite{newspeak2008}.

\begin{thebibliography}{9}

\bibitem{joepamer2011}
    Donna Malayeru, Joe Pamer, Don Syme.
    \emph{Strongly-Typed Language Supportfor an Information-Rich World}.
    Microsoft Corparation,
    2011.

\bibitem{gosuguide}
    \emph{Gosu Reference Guide}.
    Guidewire Software, Inc.
    Available at \url{http://gosu-lang.org/doc/pdf/gosuref.pdf},
    2011.

\bibitem{bracha}
    Gilad Bracha.
    \emph{Pluggable Type Systems}.
    OOPSLA Workshop on revival of Dynamic Languages.
    2004.

\bibitem{pierce}
    Benjamin C. Pierce.
    \emph{Types and Programming Languages}.
    The MIT Press, 2002.

\bibitem{javacop2010}
    S. Markstrum, D. Marino, M. Esquivel, T. D. Millstein, C. Andreae, and J. Noble.
    \emph{JavaCOP: Declarative pluggable types for Java}.
    ACM Trans. Program. Lang. Syst., 32(2), 2010.

\bibitem{checkerframework2008}
    Papi M., Ali M., Correa T.L., Perkins J., Ernst M.D..
    \emph{Practical Pluggable Types for Java}.
    ISSTA, Static Analysis, July 20–24, 2008.

\bibitem{strongtalk1993}
    Gilad Bracha, David Griswold.
    \emph{Strongtalk: Typechecking Smalltalk in a production environment}.
    Proceedings of the OOPSLA '93 Conference on Object-oriented Programming Systems, Languages and Applications, 1993.

\bibitem{newspeak2008}
    Gilad Bracha, Peter Ahe, Vassili Bykov, Eliot Miranda, Yaron Kashai.
    \emph{The Newspeak Programming Platform}.
    Cadence Design Systems.
    Available at \url{http://bracha.org/newspeak.pdf},
    2008.

\end{thebibliography}

\end{document}
